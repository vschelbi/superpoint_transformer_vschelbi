_target_: src.models.segmentation.PointSegmentationModule

num_classes: ${datamodule.num_classes}
sampling_loss: False
pointwise_loss: True
weighted_loss: True
transformer_lr_scale: 1

optimizer:
  _target_: torch.optim.AdamW
  _partial_: True
  lr: 0.01
  weight_decay: 1e-4

scheduler:
  _target_: src.optim.CosineAnnealingLRWithWarmup
  _partial_: True
  T_max: ${eval:'${trainer.max_epochs} - ${model.scheduler.num_warmup}'}
  eta_min: 1e-6
  warmup_init_lr: 1e-6
  num_warmup: 20
  warmup_strategy: 'cos'

criterion:
  _target_: torch.nn.CrossEntropyLoss
  label_smoothing: 0.0

# Parameters declared here to facilitate tuning configs. Those are only
# used here for config interpolation but will/should actually fall in
# the ignored kwargs of the PointSegmentationModule
_p: [64, 64, 128, 128]
_d: [64, 128, 256, 512]
_u: [256, 128, 64]
_d_r: 2  # number of repeated dim layers in the encoder MLPs
_u_r: 2  # number of repeated dim layers in the decoder MLPs
_p_x: ${eval:'3 + ${datamodule.feat_point} + ${model.net.point_cat_diameter}'}  # size of handcrafted level-0 node features (points)
_d_x: ${eval:'${model.net.down_inject_pos} * 3 + ${model.net.down_inject_x} * (1 + ${datamodule.feat_segment})'}  # size of handcrafted level-1+ node features
_u_x: ${eval:'${model.net.up_inject_pos} * 3 + ${model.net.up_inject_x} * (1 + ${datamodule.feat_segment})'}  # size of handcrafted level-1+ node features

net: ???
