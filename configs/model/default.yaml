_target_: src.models.segmentation.PointSegmentationModule

num_classes: ${datamodule.num_classes}
sampling_loss: False
pointwise_loss: True
weighted_loss: True
init_linear: null  # defaults to xavier_uniform initialization
init_rpe: null  # defaults to xavier_uniform initialization
multi_stage_loss_lambdas: null
transformer_lr_scale: 0.1
gc_every_n_steps: 0

optimizer:
  _target_: torch.optim.AdamW
  _partial_: True
  lr: 0.1
  weight_decay: 1e-4

scheduler:
  _target_: src.optim.CosineAnnealingLRWithWarmup
  _partial_: True
  T_max: ${eval:'${trainer.max_epochs} - ${model.scheduler.num_warmup}'}
  eta_min: 1e-6
  warmup_init_lr: 1e-6
  num_warmup: 20
  warmup_strategy: 'cos'

criterion:
  _target_: torch.nn.CrossEntropyLoss

# Parameters declared here to facilitate tuning configs. Those are only
# used here for config interpolation but will/should actually fall in
# the ignored kwargs of the PointSegmentationModule
_p: [32, 64, 128]  # point encoder layers
_d: [64, 64, 64, 64]  # encoder stage dimensions
_u: [64, 64, 64]  # decoder stage dimensions
_d_r: 2  # number of repeated dim layers in the encoder MLPs
_u_r: 2  # number of repeated dim layers in the decoder MLPs
_x_n_mlp: 64  # size of level-1+ node features after MLP, set to 'null' to use directly the raw features
_x_he_mlp: 64  # size of level-1+ horizontal edge features after MLP, set to 'null' to use directly the raw features
_x_ve_mlp: 64  # size of level-1+ vertical edge features after MLP, set to 'null' to use directly the raw features

_p_x: ${eval:'3 + ${datamodule.num_hf_point} + ${model.net.point_cat_diameter}'}  # size of handcrafted level-0 node features (points)
_x_he_raw: ${datamodule.num_hf_edge}  # size of level-1+ handcrafted horizontal edge features
_x_ve_raw: ${datamodule.num_hf_v_edge}  # size of level-1+ handcrafted vertical edge features
_d_x_pos: ${eval:'${model.net.down_inject_pos} * 3'}  # size of level-1+ injected position
_d_x_raw: ${eval:'${model.net.down_inject_x} * (${model.net.down_inject_pos} + ${datamodule.num_hf_segment})'}  # size of handcrafted level-1+ node features before node MLP (+1 for the normalization diameter)
_d_x: ${eval:'${model._d_x_pos} + (${model._x_n_mlp} if ${model._x_n_mlp} and ${model.net.down_inject_x} else ${model._d_x_raw})'}  # size of parent level-1+ node features at injection time
_u_x_pos: ${eval:'${model.net.up_inject_pos} * 3'}  # size of level-1+ injected position
_u_x_raw: ${eval:'${model.net.up_inject_x} * (${model.net.up_inject_pos} + ${datamodule.num_hf_segment})'}  # size of handcrafted level-1+ node features before node MLP (+1 for the normalization diameter)
_u_x: ${eval:'${model._u_x_pos} + (${model._x_n_mlp} if ${model._x_n_mlp} and ${model.net.up_inject_x} else ${model._u_x_raw})'}  # size of parent level-1+ node features at injection time

net: ???
